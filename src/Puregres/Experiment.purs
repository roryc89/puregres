module Puregres.Experiment where

import Prelude

-- import Control.Apply (lift2)
-- import Control.Monad.Aff (Aff)
-- import Data.Array (catMaybes, (:))
-- import Data.Either (Either(..))
-- import Data.Foreign (F, Foreign, readNull)
-- import Data.Foreign.Class (class Decode, decode)
-- import Data.Foreign.Index ((!))
-- import Data.Foreign.NullOrUndefined (NullOrUndefined(..))
-- import Data.Maybe (Maybe(..))
-- import Data.Newtype (unwrap)
-- import Data.Traversable (sequence, traverse)
-- import Database.Postgres (Client, DB, Query(..), query)
-- import Database.Postgres.SqlValue (class IsSqlValue, SqlValue, toSql)
-- import Unsafe.Coerce (unsafeCoerce)
--
-- data Table t = Table String
--
-- data SubmissionsTable = SubmissionsTable
--
-- submissions :: Table SubmissionsTable
-- submissions = Table "submissions"
--
-- data Column t a = Column String (Foreign -> F a)
--
-- submission_id :: Column SubmissionsTable Int
-- submission_id = Column "submission_id" (\f -> f ! "submission_id" >>= decode)
--
-- data SelectExpr a
--   = LeftJoin  (SelectExpr a) (SelectExpr a)
--   | RightJoin (SelectExpr a) (SelectExpr a)
--   | InnerJoin (SelectExpr a) (SelectExpr a)
--   | TableExpr (TableAndColumn a)
--
-- data TableExprVal a = TableExprVal
--
-- data TableAndColumn a = TableAndColumn String (Foreign -> F a)
--
-- cols :: forall t a. Table t -> Column t a -> TableAndColumn a
-- cols t (Column s d) = TableAndColumn s d
--
-- instance functorTableAndColumn :: Functor TableAndColumn where
--   map f (TableAndColumn s d) = (TableAndColumn s (map (map f) d))
--
-- instance functorSelectExpr :: Functor SelectExpr where
--   map f (LeftJoin sell selr) = LeftJoin (map f sell) (map f selr)
--   map f (RightJoin sell selr) = RightJoin (map f sell) (map f selr)
--   map f (InnerJoin sell selr) = InnerJoin (map f sell) (map f selr)
--   map f (TableExpr t) = TableExpr (map f t)
--
-- instance applyTableAndColumn :: Apply TableAndColumn where
--   apply (TableAndColumn t1 d1) (TableAndColumn t2 d2) =
--     TableAndColumn t1 ((lift2 apply) d1 d2)
--
-- instance applySelectExpr :: Apply SelectExpr where
--   apply (TableExpr (TableAndColumn s t1)) (TableExpr (TableAndColumn _ t2)) =
--     TableExpr (TableAndColumn s ((lift2 apply ) t1 t2))
--   apply sel1 sel2 =
-- instance applySelectExpr :: Apply SelectExpr where
--
--   apply (LeftJoin sell1 selr1) (LeftJoin sell2 selr2) =
--     LeftJoin (apply sell1 sell2) ((lift2 apply) selr1 selr2)
--
--   apply (RightJoin sell1 selr1) (RightJoin sell2 selr2) =
--       RightJoin ((lift2 apply) sell1 sell2) (apply selr1 selr2)
--
--   apply (InnerJoin sell1 selr1) (InnerJoin sell2 selr2) =
--       InnerJoin (apply sell1 sell2) (apply selr1 selr2)
--
--   apply (TableExpr t1) (TableExpr t2) =
--     TableExpr (apply t1 t2)
--   -- I don't think these cases should ever occur
--   apply (LeftJoin sell1 selr1) (RightJoin sell2 selr2) =
--     LeftJoin (apply sell1 selr2) ((lift2 apply) selr1 sell2)
--   apply (LeftJoin sell1 selr1) (InnerJoin sell2 selr2) =
--     LeftJoin (apply sell1 sell2) ((lift2 flap) selr1 selr2)
--   apply (LeftJoin sell1 selr1) (TableExpr t) =
--     TableExpr (apply sell1 (TableExpr t))
--
--   apply (LeftJoin sell1 selr1) (RightJoin sell2 selr2) =
--     RightJoin ((lift2 apply) selr1 sell2) (apply sell1 selr2)
--
--   apply (RightJoin sell1 selr1) (LeftJoin sell2 selr2) =
--     RightJoin ((lift2 apply) sell1 selr2) (apply selr1 sell2)

-- app :: forall a b. Maybe (a -> b) -> a -> Maybe b
-- app = flap
--
-- app :: forall a b. SelectExpr (Maybe (a -> b)) -> SelectExpr a -> SelectExpr (Maybe b)
-- app = lift2 flap
  -- apply (RightJoin sell1 selr1) (LeftJoin sell2 selr2) =
  --   RightJoin ((lift2 apply) sell1 selr2) (apply selr1 sell2)

-- t :: forall t a. Table t -> Column t a -> TableAndColumn a
-- t table col = s
